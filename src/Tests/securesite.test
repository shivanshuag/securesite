<?php

/**
 * @file
 * Tests for Secure Site module.
 *
 * 1 Unit tests
 *   1.1 Scripts
 *       1.1.1 stored_passwords.php
 *             1.1.1.1 Remove all users from realm.
 *             1.1.1.2 Add new user.
 *             1.1.1.3 Update existing user.
 *             1.1.1.4 Update nonexistent user.
 *             1.1.1.5 Remove existing user.
 *             1.1.1.6 Remove nonexistent user.
 *       1.1.2 digest_md5.php
 *             1.1.2.1 Check digest challenge string.
 *             1.1.2.2 No quality of protection
 *                     1.1.2.2.1 Check response to stored password.
 *                     1.1.2.2.2 Check response to expired challenge.
 *                     1.1.2.2.3 Check response to wrong password.
 *                     1.1.2.2.4 Check response to unstored password.
 *             1.1.2.3 Auth quality of protection
 *                     1.1.2.3.1 Check response to stored password.
 *                     1.1.2.3.2 Check response to replay attack.
 *   1.2 Functions
 *       1.2.1 user_save()
 *             1.2.1.1 Add new user.
 *             1.2.1.2 Update user name without changing password.
 *             1.2.1.3 Update user name and password.
 *       1.2.2 user_load()
 *             1.2.2.1 Load user without password.
 *             1.2.2.2 Load user with password.
 *       1.2.3 user_delete()
 *             1.2.3.1 Remove user.
 *       1.2.4 _securesite_forced()
 *             1.2.4.1 Check output without forced authentication.
 *             1.2.4.2 Check output with authentication always forced.
 *             1.2.4.3 Check output for on-line site with authentication forced when site is off line.
 *             1.2.4.4 Check output for off-line site with authentication forced when site is off line.
 *             1.2.4.5 Check output with authentication forced on restricted pages.
 *       1.2.5 _securesite_digest_validate()
 *             1.2.5.1 Check output without input.
 *             1.2.5.2 Check output without data.
 *             1.2.5.3 Check output with data.
 *       1.2.6 _securesite_fake_realm()
 *             1.2.6.1 Check realm with normal browser.
 *             1.2.6.2 Check realm with Internet Explorer.
 *             1.2.6.3 Check realm with Opera.
 *       1.2.7 _securesite_dialog_page()
 *             1.2.7.1 Check output with both log-in and password reset disabled.
 *             1.2.7.2 Check output with log-in enabled and password reset disabled.
 *             1.2.7.3 Check output with log-in disabled and password reset enabled.
 *             1.2.7.4 Check output with both log-in and password reset enabled.
 * 2 Functional tests
 *   2.1 Name conflict prevention
 *       2.1.1 Register user with guest name.
 *       2.1.2 Create user with guest name.
 *       2.1.3 Set user name to guest name.
 *       2.1.4 Set guest name to user name.
 *   2.2 Forced authentication
 *       2.2.1 Disabled
 *             2.2.1.1 Request home page.
 *       2.2.2 Always
 *             2.2.2.1 Request home page.
 *             2.2.2.2 Request home page with logged in user.
 *             2.2.2.3 Request home page with logged in guest.
 *             2.2.2.4 Try valid reset page URL.
 *             2.2.2.5 Try invalid reset page URL.
 *             2.2.2.6 Submit password reset form.
 *             2.2.2.7 Try cron.php with all authentication types enabled.
 *             2.2.2.8 Try cron.php with only form authentication enabled.
 *       2.2.3 Offline
 *             2.2.3.1 Request on-line home page.
 *             2.2.3.2 Request off-line home page.
 *       2.2.4 403
 *             2.2.4.1 Logged out
 *                     2.2.4.1.1 Request home page.
 *                     2.2.4.1.2 Request admin page.
 *             2.2.4.2 Logged in
 *                     2.2.4.2.1 Request admin page for non-admin user.
 *       2.2.5 403 error configuration
 *             2.2.5.1 Check access denied page when setting forced authentication on restricted pages.
 *             2.2.5.2 Keep current access denied page when no previous setting exists.
 *             2.2.5.3 Save previous access denied page.
 *             2.2.5.4 Restore previous access denied page.
 *   2.3 Basic authentication
 *       2.3.1 Request home page without credentials.
 *       2.3.2 Registered user
 *             2.3.2.1 Request home page with wrong password.
 *             2.3.2.2 Request home page with correct password and access disabled.
 *             2.3.2.3 Request home page with correct password and access enabled.
 *             2.3.2.4 Request log-out page.
 *             2.3.2.5 Request home page with credentials for new user.
 *       2.3.3 Guest user
 *             2.3.3.1 Password not set
 *                     2.3.3.1.1 Request home page with empty credentials and access disabled.
 *                     2.3.3.1.2 Request home page with empty credentials and access enabled.
 *                     2.3.3.1.3 Request home page with random credentials and access disabled.
 *                     2.3.3.1.4 Request home page with random credentials and access enabled.
 *                     2.3.3.1.5 Request home page with credentials for new user.
 *             2.3.3.2 Password set and access enabled
 *                     2.3.3.2.1 Request home page with empty credentials.
 *                     2.3.3.2.2 Request home page with random credentials.
 *                     2.3.3.2.3 Request home page with guest credentials.
 *   2.4 Form authentication
 *       2.4.1 Request home page without credentials.
 *       2.4.2 Registered user
 *             2.4.2.1 Request home page with wrong password.
 *             2.4.2.2 Request home page with correct password and access disabled.
 *             2.4.2.3 Request home page with correct password and access enabled.
 *       2.4.3 Guest user
 *             2.4.3.1 Request home page with empty credentials and access disabled.
 *             2.4.3.2 Request home page with random credentials and access disabled.
 *             2.4.3.3 Request home page with random credentials and access enabled.
 *   2.5 Digest authentication
 *       2.5.1 Request home page without credentials.
 *       2.5.2 Registered user with access enabled
 *             2.5.2.1 Unstored password
 *                     2.5.2.1.1 Request home page with basic fall-back.
 *                     2.5.2.1.2 Request home page with form fall-back.
 *                     2.5.2.1.3 Store password with fall-back authentication method.
 *             2.5.2.2 Stored password
 *                     2.5.2.2.1 Request home page with wrong password.
 *                     2.5.2.2.2 Request home page with correct password.
 *                     2.5.2.2.3 Request log-out page.
 *       2.5.3 Guest user with access enabled
 *             2.5.3.1 Password not set
 *                     2.5.3.1.1 Request home page with empty credentials.
 *                     2.5.3.1.2 Request home page with random credentials.
 *             2.5.3.2 Password set
 *                     2.5.3.2.1 Request home page with empty credentials.
 *                     2.5.3.2.2 Request home page with random credentials.
 *                     2.5.3.2.3 Request home page with correct credentials.
 */

/**todo change drupalPost to drupalPostForm
 * todo change DrupalWebTestCase to Drupal\simpletest\WebTestBase
 * todo change class names to end with Test
 * todo put each class in its own file and use proper comment at the beginning of each file - see https://drupal.org/node/325974
 * see https://drupal.org/node/2166895

/**
 * Unit tests for stored_passwords.php.
 */
class SecureSiteScriptStoredPasswordsUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => 'stored_passwords.php',
      'description' => t('Test password storage script. Digest scripts must be configured on the live site before these tests can be run.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    _securesite_copy_script_config($this);
    $this->user = $this->drupalCreateUser();
    $this->realm = \Drupal::config('securesite.settings')->get('securesite_realm');
    $this->name_arg = 'username=' . escapeshellarg($this->user->name);
    $this->pass_arg = 'pass=' . escapeshellarg($this->user->pass_raw);
    $this->realm_arg = 'realm=' . escapeshellarg($this->realm);
  }

  /**
   * Remove all users from realm.
   */
  function testSecureSiteScriptsStoredPasswordsRealm() {
    $command = "$this->stored_passwords $this->realm_arg op=delete";
    $this->assertTrue(exec($command) == "Removed users from $this->realm.", t('Removing all users from realm.'));
  }

  /**
   * Add new user.
   */
  function testSecureSiteScriptsStoredPasswordsAdd() {
    $command = "$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg op=create";
    $this->assertTrue(exec($command) == 'Added ' . $this->user->name . " to $this->realm.", t('Adding new user.'));
  }

  /**
   * Update existing user.
   */
  function testSecureSiteScriptsStoredPasswordsUpdateExisting() {
    exec("$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg op=create");
    $command = "$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg";
    $this->assertTrue(exec($command) == 'Updated ' . $this->user->name . " in $this->realm.", t('Updating existing user.'));
  }

  /**
   * Update nonexistent user.
   */
  function testSecureSiteScriptsStoredPasswordsUpdateNonexistent() {
    $command = "$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg";
    $this->assertTrue(exec($command) == $this->user->name . " not found in $this->realm.", t('Updating nonexistent user.'));
  }

  /**
   * Remove existing user.
   */
  function testSecureSiteScriptsStoredPasswordsDeleteExisting() {
    exec("$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg op=create");
    $command = "$this->stored_passwords $this->name_arg $this->realm_arg op=delete";
    $this->assertTrue(exec($command) == 'Removed ' . $this->user->name . " from $this->realm.", t('Removing existing user.'));
  }

  /**
   * Remove nonexistent user.
   */
  function testSecureSiteScriptsStoredPasswordsDeleteNonexistent() {
    $command = "$this->stored_passwords $this->name_arg $this->realm_arg op=delete";
    $this->assertTrue(exec($command) == $this->user->name . " not found in $this->realm.", t('Removing nonexistent user.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    exec("$this->stored_passwords $this->realm_arg op=delete");
    parent::tearDown();
  }
}

/**
 * Unit tests for digest_md5.php.
 */
class SecureSiteScriptDigestMD5UnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => 'digest_md5.php',
      'description' => t('Test digest challenge script. Digest scripts must be configured on the live site before these tests can be run.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    _securesite_copy_script_config($this);
    //todo find a workaround for default value
    variable_set('securesite_type', array(SECURESITE_DIGEST));
    module_load_include('inc', 'securesite');
    $this->user = $this->drupalCreateUser();
    $this->realm = \Drupal::config('securesite.settings')->get('securesite_realm');
    module_load_include('inc', 'securesite');
    $this->challenge = _securesite_parse_directives(exec($this->digest_md5 . ' realm=' . escapeshellarg($this->realm)));
    $this->data = array(
      'username="' . $this->user->name . '"',
      'realm="' . $this->challenge['realm'] . '"',
      'uri=/',
    );
    $this->auth = $this->data;
    $this->auth[] = 'qop="auth"';
    $this->auth[] = 'opaque="' . $this->challenge['opaque'] . '"';
    // Store password.
    $name = 'username=' . escapeshellarg($this->user->name);
    $pass = 'pass=' . escapeshellarg($this->user->pass_raw);
    $realm = 'realm=' . escapeshellarg($this->realm);
    exec("$this->stored_passwords $name $pass $realm op=create");
  }

  /**
   * Check digest challenge string.
   */
  function testSecureSiteScriptDigestMD5Challenge() {
    $this->assertTrue(isset($this->challenge['realm']) && $this->challenge['realm'] == $this->realm && isset($this->challenge['nonce']), t('Checking digest challenge string.'));
  }

  /**
   * Check response to stored password.
   */
  function testSecureSiteScriptDigestMD5Stored() {
    $ha1 = md5($this->user->name . ':' . $this->challenge['realm'] . ':' . $this->user->pass_raw);
    $response = md5($ha1 . ':' . $this->challenge['nonce'] . ':' . md5('GET:/'));
    $this->data[] = 'nonce="' . $this->challenge['nonce'] . '"';
    $this->data[] = 'response="' . $response . '"';
    $command = $this->digest_md5 . ' data=' . escapeshellarg(implode(', ', $this->data)) . ' method=GET';
    module_load_include('inc', 'securesite');
    $authentication = _securesite_parse_directives(exec($command, $output, $status));
    $rspauth = md5($ha1 . ':' . $this->challenge['nonce'] . ':' . md5(':/'));
    $this->assertTrue($status == 0 && isset($authentication['rspauth']) && $authentication['rspauth'] == $rspauth, t('Checking response to stored password.'));
  }

  /**
   * Check response to expired challenge.
   */
  function testSecureSiteScriptDigestMD5Expired() {
    $ha1 = md5($this->user->name . ':' . $this->challenge['realm'] . ':' . $this->user->pass_raw);
    $response = md5($ha1 . ':' . $this->challenge['nonce'] . $this->challenge['nonce'] . ':' . md5('GET:/'));
    $this->data[] = 'nonce="' . $this->challenge['nonce'] . $this->challenge['nonce'] . '"';
    $this->data[] = 'response="' . $response . '"';
    $command = $this->digest_md5 . ' data=' . escapeshellarg(implode(', ', $this->data)) . ' method=GET';
    module_load_include('inc', 'securesite');
    $authentication = _securesite_parse_directives(exec($command, $output, $status));
    $this->assertTrue($status == 5 && isset($authentication['realm']) && isset($authentication['nonce']), t('Checking response to expired credentials.'));
  }

  /**
   * Check response to wrong password.
   */
  function testSecureSiteScriptDigestMD5Wrong() {
    $ha1 = md5($this->user->name . ':' . $this->challenge['realm'] . ':' . $this->user->pass);
    $response = md5($ha1 . ':' . $this->challenge['nonce'] . ':' . md5('GET:/'));
    $this->data[] = 'nonce="' . $this->challenge['nonce'] . '"';
    $this->data[] = 'response="' . $response . '"';
    $command = $this->digest_md5 . ' data=' . escapeshellarg(implode(', ', $this->data)) . ' method=GET';
    module_load_include('inc', 'securesite');
    $authentication = _securesite_parse_directives(exec($command, $output, $status));
    $this->assertTrue($status == 3 && isset($authentication['realm']) && isset($authentication['nonce']), t('Checking response to wrong password.'));
  }

  /**
   * Check response to unstored password.
   */
  function testSecureSiteScriptDigestMD5Unstored() {
    exec("$this->stored_passwords realm=" . escapeshellarg($this->realm) . ' op=delete');
    $ha1 = md5($this->user->name . ':' . $this->challenge['realm'] . ':' . $this->user->pass_raw);
    $response = md5($ha1 . ':' . $this->challenge['nonce'] . ':' . md5('GET:/'));
    $this->data[] = 'nonce="' . $this->challenge['nonce'] . '"';
    $this->data[] = 'response="' . $response . '"';
    $command = $this->digest_md5 . ' data=' . escapeshellarg(implode(', ', $this->data)) . ' method=GET';
    module_load_include('inc', 'securesite');
    $authentication = _securesite_parse_directives(exec($command, $output, $status));
    $this->assertTrue($status == 2 && isset($authentication['realm']) && isset($authentication['nonce']), t('Checking response to unstored password.'));
  }

  /**
   * Check response to stored password with auth quality of protection.
   */
  function testSecureSiteScriptDigestMD5AuthStored() {
    $ha1 = md5($this->user->name . ':' . $this->challenge['realm'] . ':' . $this->user->pass_raw);
    $cnonce = uniqid();
    $response = md5($ha1 . ':' . $this->challenge['nonce'] . ":00000001:$cnonce:auth:" . md5('GET:/'));
    $this->auth[] = 'nonce="' . $this->challenge['nonce'] . '"';
    $this->auth[] = 'cnonce="' . $cnonce . '"';
    $this->auth[] = 'nc=00000001';
    $this->auth[] = 'response="' . $response . '"';
    $command = $this->digest_md5 . ' data=' . escapeshellarg(implode(', ', $this->auth)) . ' method=GET';
    module_load_include('inc', 'securesite');
    $authentication = _securesite_parse_directives(exec($command, $output, $status));
    $rspauth = md5($ha1 . ':' . $this->challenge['nonce'] . ":00000001:$cnonce:auth:" . md5(':/'));
    $this->assertTrue($status == 0 && isset($authentication['rspauth']) && $authentication['rspauth'] == $rspauth, t('Checking response to stored password with %qop quality of protection.', array('%qop' => 'auth')));
  }

  /**
   * Check response to replay attack with auth quality of protection.
   */
  function testSecureSiteScriptDigestMD5AuthReplay() {
    $ha1 = md5($this->user->name . ':' . $this->challenge['realm'] . ':' . $this->user->pass_raw);
    $cnonce = uniqid();
    $response = md5($ha1 . ':' . $this->challenge['nonce'] . ":00000001:$cnonce:auth:" . md5('GET:/'));
    $this->auth[] = 'nonce="' . $this->challenge['nonce'] . '"';
    $this->auth[] = 'cnonce="' . $cnonce . '"';
    $this->auth[] = 'nc=00000001';
    $this->auth[] = 'response="' . $response . '"';
    $command = $this->digest_md5 . ' data=' . escapeshellarg(implode(', ', $this->auth)) . ' method=GET';
    exec($command);
    module_load_include('inc', 'securesite');
    $authentication = _securesite_parse_directives(exec($command, $output, $status));
    $this->assertTrue($status == 4 && isset($authentication['realm']) && isset($authentication['nonce']), t('Checking response to replay attack with %qop quality of protection.', array('%qop' => 'auth')));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    exec("$this->stored_passwords realm=" . escapeshellarg($this->realm) . ' op=delete');
    parent::tearDown();
  }
}

/**
 * Unit tests for user_save().
 */
class SecureSiteFunctionUserSaveUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => 'user_save()',
      'description' => t('Test password storage when user is added or updated. Digest scripts must be configured on the live site before these tests can be run.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    _securesite_copy_script_config($this);
    //todo find a workaround for default value
    variable_set('securesite_type', array(SECURESITE_DIGEST));
    $this->user = $this->drupalCreateUser();
    $this->realm = \Drupal::config('securesite.settings')->get('securesite_realm');
    $this->name_arg = 'username=' . escapeshellarg($this->user->name);
    $this->pass_arg = 'pass=' . escapeshellarg($this->user->pass_raw);
    $this->realm_arg = 'realm=' . escapeshellarg($this->realm);
  }

  /**
   * Add new user.
   */
  function testSecureSiteFunctionUserSaveAdd() {
    $command = "$this->stored_passwords username=" . escapeshellarg($this->user->name) . " $this->pass_arg $this->realm_arg";
    $this->assertTrue(exec($command) == 'Updated ' . $this->user->name . " in $this->realm.", t('Adding new user.'));
  }

  /**
   * Update user name without changing password.
   */
  function testSecureSiteFunctionUserSaveUpdatePassUnchanged() {
    $user = user_save($this->user, array('name' => $this->randomName()));
    $command = "$this->stored_passwords username=" . escapeshellarg($user->name) . " $this->pass_arg $this->realm_arg";
    $this->assertTrue(exec($command) == "$user->name not found in $this->realm.", t('Updating user name without changing password.'));
  }

  /**
   * Update user name and password.
   */
  function testSecureSiteFunctionUserSaveUpdatePassChanged() {
    $user = user_save($this->user, array('name' => $this->randomName(), 'pass' => user_password()));
    $old = exec("$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg");
    $new = exec("$this->stored_passwords username=" . escapeshellarg($user->name) . " $this->pass_arg $this->realm_arg");
    $this->assertTrue($old == $this->user->name . " not found in $this->realm." && $new == "Updated $user->name in $this->realm.", t('Updating user name and password.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    exec("$this->stored_passwords $this->realm_arg op=delete");
    parent::tearDown();
  }
}

/**
 * Unit tests for user_load().
 */
class SecureSiteFunctionUserLoadUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => 'user_load()',
      'description' => t('Test password storage when user is loaded. Digest scripts must be configured on the live site before these tests can be run.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    _securesite_copy_script_config($this);
    $this->user = $this->drupalCreateUser();
    $this->realm = \Drupal::config('securesite.settings')->get('securesite_realm');
    $this->name_arg = 'username=' . escapeshellarg($this->user->name);
    $this->pass_arg = 'pass=' . escapeshellarg($this->user->pass_raw);
    $this->realm_arg = 'realm=' . escapeshellarg($this->realm);
    //todo the default value in this is different from what we have in securesite.settings
    variable_set('securesite_type', array(SECURESITE_DIGEST));
  }

  /**
   * Load user without password.
   */
  function testSecureSiteUserLoadUID() {
    // Added by sime in D7 upgrade.
    // @todo Coder module instructs that we should convert "user_load" to "user_load_multiple" if "$this->user->uid" is other than a uid.  To return a single user object, wrap "user_load_multiple" with "array_shift" or equivalent. Example: array_shift(user_load_multiple(array(), $this->user->uid)) -- HOWEVER I'm not sure how to do this yet since this is not appararently returning anything.
    // @todo Look at how user tests work in D7.

    // Old test
    // user_load($this->user->uid);
    // $command = "$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg";
    // $this->assertTrue(exec($command) == $this->user->name . " not found in $this->realm.", t('Loading user without password.'));

    // New test
    $accounts = user_load_multiple(array(), array('uid' => $this->user->uid));
    // $new_user = reset($accounts); // Needed?
    $command = "$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg";
    $this->assertTrue(exec($command) == $this->user->name . " not found in $this->realm.", t('Loading user without password.'));
  }

  /**
   * Load user with password.
   */
  function testSecureSiteUserLoadPass() {
    // D6: user_load(array('uid' => $this->user->uid, 'pass' => $this->user->pass_raw));
    // sime: D6 code doesn't return anything so I assume no array shifting or reset() is needed for D7 code.
    user_load_multiple(array($this->user->uid), array('pass' => $this->user->pass_raw));
    $command = "$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg";
    $this->assertTrue(exec($command) == 'Updated ' . $this->user->name . " in $this->realm.", t('Loading user with password.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    exec("$this->stored_passwords $this->realm_arg op=delete");
    parent::tearDown();
  }
}

/**
 * Unit test for user_delete().
 */
class SecureSiteFunctionUserDeleteUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => 'user_delete()',
      'description' => t('Test password removal when user is deleted. Digest scripts must be configured on the live site before this test can be run.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    _securesite_copy_script_config($this);
    //todo the default value in this is different from what we have in securesite.settings
    variable_set('securesite_type', array(SECURESITE_DIGEST));
    $this->user = $this->drupalCreateUser();
    $this->realm =  \Drupal::config('securesite.settings')->get('securesite_realm');
    $this->name_arg = 'username=' . escapeshellarg($this->user->name);
    $this->pass_arg = 'pass=' . escapeshellarg($this->user->pass_raw);
    $this->realm_arg = 'realm=' . escapeshellarg($this->realm);
  }

  /**
   * Remove user.
   */
  function testSecureSiteFunctionUserDelete() {
    user_cancel(array(), $this->user->uid, $method = 'user_cancel_delete');
    $command = "$this->stored_passwords $this->name_arg $this->pass_arg $this->realm_arg";
    $this->assertTrue(exec($command) == $this->user->name . " not found in $this->realm.", t('Removing user.'));
  }
}

/**
 * Unit tests for _securesite_forced().
 */
class SecureSiteFunctionForcedUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => '_securesite_forced()',
      'description' => t('Check forced authentication.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    module_load_include('inc', 'securesite');
  }

  /**
   * Check output without forced authentication.
   */
  function testSecureSiteFunctionForcedDisabled() {
    $this->assertFalse(_securesite_forced(), t('Checking output without forced authentication.'));
  }

  /**
   * Check output with authentication always forced.
   */
  function testSecureSiteFunctionForcedAlways() {
    //todo - default value
    variable_set('securesite_enabled', SECURESITE_ALWAYS);
    $this->assertTrue(_securesite_forced(), t('Checking output with authentication always forced.'));
  }

  /**
   * Check output with authentication forced when site is off line.
   */
  function testSecureSiteFunctionForcedOffline() {
    //todo default value
    variable_set('securesite_enabled', SECURESITE_OFFLINE);
    $this->assertFalse(_securesite_forced(), t('Checking output for on-line site with authentication forced when site is off line.'));
    \Drupal::state()->set('system.maintenance_mode', 1);
    $this->assertTrue(_securesite_forced(), t('Checking output for off-line site with authentication forced when site is off line.'));
  }

  /**
   * Check output with authentication forced on restricted pages.
   */
  function testSecureSiteFunctionForced403() {
    //todo default value
    variable_set('securesite_enabled', SECURESITE_403);
    \Drupal::config('securesite.settings')->get('securesite_403');
    variable_set('site_403', 'securesite_403');
    $this->assertFalse(_securesite_forced(), t('Checking output with authentication forced on restricted pages.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    $config_securesite = \Drupal::config('securesite.settings');
    $config_securesite->clear('securesite_enabled');
    //variable_del('site_offline');
    \Drupal::config('system.site')->clear('page.403')->save();
    $config_securesite->clear('securesite_403');
    $config_securesite->save();
    parent::tearDown();
  }
}

/**
 * Unit tests for _securesite_digest_validate().
 */
class SecureSiteFunctionDigestValidateUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => '_securesite_digest_validate()',
      'description' => t('Test digest header strings. Digest scripts must be configured on the live site before these tests can be run.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    _securesite_copy_script_config($this);
    module_load_include('inc', 'securesite');
    $this->realm = \Drupal::config('securesite.settings')->get('securesite_realm');
  }

  /**
   * Check output without input.
   */
  function testSecureSiteFunctionDigestValidateNull() {
    $header = _securesite_digest_validate($status);
    $this->assertTrue(!isset($header) && !isset($status), t('Checking output without input.'));
  }

  /**
   * Check output without data.
   */
  function testSecureSiteFunctionDigestValidateEmpty() {
    _securesite_digest_validate($status, array('realm' => $this->realm));
    $this->assertTrue(strpos(_securesite_digest_validate($status), 'WWW-Authenticate') === 0 && $status === 0, t('Checking output without data.'));
  }

  /**
   * Check output with data.
   */
  function testSecureSiteFunctionDigestValidateData() {
    //todo - default value
    variable_set('securesite_type', array(SECURESITE_DIGEST));
    $user = $this->drupalCreateUser();
    module_load_include('inc', 'securesite');
    $challenge = _securesite_parse_directives(exec($this->digest_md5 . ' realm=' . escapeshellarg($this->realm)));
    $ha1 = md5("$user->name:$challenge[realm]:$user->pass_raw");
    $data = array(
      'username="' . $user->name . '"',
      'realm="' . $challenge['realm'] . '"',
      'uri=/',
      'nonce="' . $challenge['nonce'] . '"',
      'response="' . md5("$ha1:$challenge[nonce]:" . md5('GET:/')) . '"',
    );
    _securesite_digest_validate($status, array('data' => implode(', ', $data), 'method' => 'GET'));
    $this->assertTrue(strpos(_securesite_digest_validate($status), 'Authentication-Info') === 0 && $status === 0, t('Checking output with data.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    \Drupal::config('securesite.settings')->clear('securesite_type')->save();
    parent::tearDown();
  }
}

/**
 * Unit tests for _securesite_fake_realm().
 */
class SecureSiteFunctionFakeRealmUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => '_securesite_fake_realm()',
      'description' => t('Test log-out workaround for Internet Explorer and Opera.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    module_load_include('inc', 'securesite');
    $this->user_agent = $_SERVER['HTTP_USER_AGENT'];
    $this->fake_realm = _securesite_fake_realm();
  }

  /**
   * Check realm with normal browser.
   */
  function testSecureSiteFunctionFakeRealmNormal() {
    $this->assertTrue($this->fake_realm == _securesite_fake_realm(), t('Checking realm with normal browser.'));
  }

  /**
   * Check realm with Internet Explorer.
   */
  function testSecureSiteFunctionFakeRealmMSIE() {
    $_SERVER['HTTP_USER_AGENT'] = 'msie';
    $this->assertTrue($this->fake_realm != _securesite_fake_realm(), t('Checking realm with Internet Explorer.'));
  }

  /**
   * Check realm with Opera.
   */
  function testSecureSiteFunctionFakeRealmOpera() {
    $_SERVER['HTTP_USER_AGENT'] = 'opera';
    $this->assertTrue($this->fake_realm != _securesite_fake_realm(), t('Checking realm with Opera.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    $_SERVER['HTTP_USER_AGENT'] = $this->user_agent;
    parent::tearDown();
  }
}

/**
 * Unit tests for _securesite_dialog_page().
 */
class SecureSiteFunctionDialogPageUnitTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => '_securesite_dialog_page()',
      'description' => t('Test dialog page output.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    module_load_include('inc', 'securesite');
  }

  /**
   * Check output with both log-in and password reset disabled.
   */
  function testSecureSiteDialogPageNeither() {
    \Drupal::config('securesite.settings')->set('securesite_reset_form', '');
    $page = _securesite_dialog_page();
    $login = strpos($page, 'id="securesite-user-login"') === FALSE;
    $reset = strpos($page, 'id="securesite-user-pass"') === FALSE;
    $message = strpos($page, 'Reload the page to try logging in again.') === FALSE;
    $this->assertTrue($login && $reset && !$message, t('Checking output with both log-in and password reset disabled.'));
  }

  /**
   * Check output with log-in enabled and password reset disabled.
   */
  function testSecureSiteDialogPageLogin() {
    $config = \Drupal::config('securesite.settings');
    $config->set('securesite_type', array(SECURESITE_FORM));
    $config->set('securesite_reset_form', '');
    $config->save();
    $page = _securesite_dialog_page();
    $login = strpos($page, 'id="securesite-user-login"') === FALSE;
    $reset = strpos($page, 'id="securesite-user-pass"') === FALSE;
    $message = strpos($page, 'Reload the page to try logging in again.') === FALSE;
    $this->assertTrue(!$login && $reset && $message, t('Checking output with log-in enabled and password reset disabled.'));
  }

  /**
   * Check output with log-in disabled and password reset enabled.
   */
  function testSecureSiteDialogPageReset() {
    $page = _securesite_dialog_page();
    $login = strpos($page, 'id="securesite-user-login"') === FALSE;
    $reset = strpos($page, 'id="securesite-user-pass"') === FALSE;
    $message = strpos($page, 'Reload the page to try logging in again.') === FALSE;
    $this->assertTrue($login && !$reset && $message, t('Checking output with log-in disabled and password reset enabled.'));
  }

  /**
   * Check output with both log-in and password reset enabled.
   */
  function testSecureSiteDialogPageBoth() {
    \Drupal::config('securesite.settings')->set('securesite_type', array(SECURESITE_FORM))->save();
    $page = _securesite_dialog_page();
    $login = strpos($page, 'id="securesite-user-login"') === FALSE;
    $reset = strpos($page, 'id="securesite-user-pass"') === FALSE;
    $message = strpos($page, 'Reload the page to try logging in again.') === FALSE;
    $this->assertTrue(!$login && !$reset && $message, t('Checking output with both log-in and password reset enabled.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    $config = \Drupal::config('securesite.settings');
    $config->clear('securesite_type');
    $config->clear('securesite_reset_form');
    $config->save();
    drupal_clean_css_identifier(NULL, TRUE);
    parent::tearDown();
  }
}

/**
 * Functional tests for conflicts between guest name and user names.
 */
class SecureSiteNameConflictFunctionalTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => t('Name conflict prevention'),
      'description' => t('Test prevention of conflicts between guest name and user names.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    user_role_grant_permissions(DRUPAL_ANONYMOUS_RID, array('access secured pages'));
    $this->guest = $this->randomName();
    \Drupal::config('securesite.settings')->set('securesite_guest_name', $this->guest)->save();
    $this->user = $this->drupalCreateUser(array('administer site configuration', 'administer users', 'change own username'));
  }

  /**
   * Register user with guest name.
   */
  function testSecureSiteNameConflictUserRegister() {
    $this->drupalPost('user/register', array('name' => $this->guest, 'mail' => $this->guest . '@example.com'), 'Create new account');
    $this->assertText("The name $this->guest is being used as the " . \Drupal::config('system.site')->get('name') . " guest name.", t('Registering user with guest name.'));
    $this->assertTrue(db_query("SELECT uid FROM {users} WHERE name = :name", array(':name' => $this->guest))->fetchField() === FALSE, t('Checking for user with guest name.'));
  }

  /**
   * Create user with guest name.
   */
  function testSecureSiteNameConflictUserCreate() {
    $this->drupalLogin($this->user);
    $this->drupalPost('admin/user/user/create', array('name' => $this->guest, 'mail' => $this->guest . '@example.com', 'pass[pass1]' => $this->user->pass_raw, 'pass[pass2]' => $this->user->pass_raw), 'Create new account');
    $this->assertText("The name $this->guest is being used as the " . \Drupal::config('system.site')->get('name') . " guest name.", t('Creating user with guest name.'));
    $this->assertTrue(db_query("SELECT uid FROM {users} WHERE name = :name", array(':name' => $this->guest))->fetchField() === FALSE, t('Checking for user with guest name.'));
  }

  /**
   * Set user name to guest name.
   */
  function testSecureSiteNameConflictUserEdit() {
    $this->drupalLogin($this->user);
    $this->drupalPost('user/' . $this->user->uid . '/edit', array('name' => $this->guest), 'Save');
    $this->assertText("The name $this->guest is being used as the " . \Drupal::config('system.site')->get('name') . " guest name.", t('Setting user name to guest name.'));
    $this->assertTrue(db_query("SELECT uid FROM {users} WHERE name = :name", array(':name' => $this->guest))->fetchField() === FALSE, t('Checking for user with guest name.'));
  }

  /**
   * Set guest name to user name.
   */
  function testSecureSiteNameConflictGuest() {
    $this->drupalLogin($this->user);
    $this->drupalPost('admin/config/securesite', array('securesite_guest_name' => $this->user->name), 'Save configuration');
    $this->assertText('The name ' . $this->user->name . ' belongs to a registered user.', t('Setting guest name to user name.'));
    $this->assertNotEqual(\Drupal::config('securesite.settings')->get('securesite_guest_name'), $this->user->name, t('Checking for guest with user name.'));
  }
}





/**
 * Functional tests for configuring access denied page.
 */
class SecureSiteConfig403FunctionalTest extends DrupalWebTestCase {
  /**
   * Implements getInfo().
   */
  function getInfo() {
    return array(
      'name' => '403 error configuration',
      'description' => t('Test configuration for access denied page.'),
      'group' => t('Secure Site'),
    );
  }

  /**
   * Implements setUp().
   */
  function setUp() {
    parent::setUp('securesite');
    $this->drupalLogin($this->drupalCreateUser(array('administer site configuration')));
  }

  /**
   * Check access denied page when setting forced authentication on restricted pages.
   */
  function testSecureSiteConfig403Save() {
    $this->drupalPost('admin/config/securesite', array('securesite_enabled' => SECURESITE_403), 'Save configuration');
    $this->assertTrue( \Drupal::config('system.site')->get('page.403') == 'securesite_403', t('Checking access denied page when setting forced authentication on restricted pages.'));
  }

  /**
   * Keep current access denied page when no previous setting exists.
   */
  function testSecureSiteConfig403ResetCurrent() {
    \Drupal::config('system.site')->set('page.403', 'site_403')->save();
    $this->drupalPost('admin/config/securesite', array(), 'Reset to defaults');
    $this->assertTrue(\Drupal::config('system.site')->get('page.403') == 'site_403', t('Keeping current access denied page when no previous setting exists.'));
  }

  /**
   * Save previous access denied page.
   */
  function testSecureSiteConfig403Page() {
    $this->drupalPost('admin/config/development/logging', array('site_403' => 'site_403'), 'Save configuration');
    $config = \Drupal::config('securesite.settings');
    $config->set('securesite_enabled', SECURESITE_403)->save();
    $this->drupalPost('admin/config/development/logging', array(), 'Save configuration');
    $this->assertTrue($config->get('securesite_403') == 'site_403', t('Saving previous access denied page.'));
  }

  /**
   * Restore previous access denied page.
   */
  function testSecureSiteConfig403ResetPrevious() {
    \Drupal::config('securesite.settings')->set('securesite_403', 'site_403')->save();
    $this->drupalPost('admin/config/development/logging', array(), 'Reset to defaults');
    $this->assertTrue(\Drupal::config('system.site')->get('page.403') == 'site_403', t('Restoring previous access denied page.'));
  }

  /**
   * Implements tearDown().
   */
  function tearDown() {
    $config = \Drupal::config('securesite.settings');
    $config->clear('securesite_enabled');
    $config->clear('securesite_403');
    $config->save();
    \Drupal::config('system.site')->clear('page.403')->save();
    parent::tearDown();
  }
}
















/**
 * Copy script configuration from live site to test site.
 *
 * @param $object
 *   Object to which scripts should be copied.
 */
//todo - understand this
function _securesite_copy_script_config($object) {
  global $conf, $db_prefix;
  $config = \Drupal::config('securesite.settings');
  $conf = array();
  $_db_prefix = $db_prefix;
  @include './' . conf_path() . '/settings.php';
  //$conf = variable_initialize($conf);
  $object->digest_md5 = $config->get('securesite_digest_script');
  $object->stored_passwords =  $config>get('securesite_password_script');
  $conf = array();
  @include './' . conf_path() . '/settings.php';
  $db_prefix = $_db_prefix;
  //$conf = variable_initialize($conf);
  $config->set('securesite_digest_script', $object->digest_md5);
  $config->set('securesite_password_script', $object->stored_passwords);
  $config->save();
}
